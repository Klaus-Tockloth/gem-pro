package main

import (
	"fmt"
	"net/url"
	"os"
	"strings"
	"time"

	"google.golang.org/genai"
)

/*
printPromptResponseToTerminal prints the content of the ANSI prompt/response file to the standard output (terminal).
It reads the content from the ANSI formatted prompt / response file and writes it directly to the standard output,
displaying colored text in the terminal.
*/
func printPromptResponseToTerminal() {
	data, err := os.ReadFile(progConfig.AnsiPromptResponseFile)
	if err != nil {
		fmt.Printf("error [%v] at os.ReadFile()\n", err)
		return
	}
	os.Stdout.Write(data)
}

/*
processPrompt processes the user prompt and prepares it for different output formats (Markdown, ANSI, HTML).
It takes a user prompt, formats it into Markdown, ANSI, and HTML, including system instructions and referenced
files, and saves these formats to respective files.
*/
func processPrompt(prompt string, chatmode bool, chatNumber int) {
	var promptString strings.Builder

	// text part of prompt (also included in contents)
	promptString.WriteString("***\n")
	if chatmode {
		if chatNumber == 1 {
			promptString.WriteString("**Prompt to Gemini (initial chat #1):**\n")
		} else {
			promptString.WriteString(fmt.Sprintf("**Prompt to Gemini (refinement chat #%d):**\n", chatNumber))
		}
	} else {
		promptString.WriteString("**Prompt to Gemini:**\n")
	}
	promptString.WriteString("\n```plaintext\n")
	promptString.WriteString(prompt)
	promptString.WriteString("\n```\n")
	promptString.WriteString("\n***\n")

	// system instructions part of prompt (not included in contents, but important)
	if progConfig.GeminiSystemInstruction != "" {
		promptString.WriteString("**System Instruction to Gemini:**\n")
		promptString.WriteString("\n```plaintext\n")
		promptString.WriteString(progConfig.GeminiSystemInstruction)
		promptString.WriteString("\n```\n")
		promptString.WriteString("\n***\n")
	}

	if (chatmode && chatNumber == 1) || !chatmode {
		if len(filesToUpload) > 0 {
			promptString.WriteString("**Data referenced by the Prompt:**\n")
			promptString.WriteString("\n```plaintext\n")
			for _, fileToUpload := range filesToUpload {
				if fileToUpload.state != "error" {
					promptString.WriteString(fmt.Sprintf("%-5s %s (%s, %s, %s)\n",
						fileToUpload.state, fileToUpload.filepath,
						fileToUpload.lastUpdate, fileToUpload.fileSize, fileToUpload.mimeType))
				} else {
					promptString.WriteString(fmt.Sprintf("%-5s %s %s\n",
						fileToUpload.state, fileToUpload.filepath, fileToUpload.errorMessage))
				}
			}
			promptString.WriteString("```\n")
			promptString.WriteString("\n***\n")
		}
	}

	// write prompt to current markdown request/response file
	err := os.WriteFile(progConfig.MarkdownPromptResponseFile, []byte(promptString.String()), 0666)
	if err != nil {
		fmt.Printf("error [%v] at os.WriteFile()\n", err)
		return
	}

	// render prompt as ansi
	ansiData := promptString.String()
	if progConfig.AnsiRendering {
		ansiData = renderMarkdown2Ansi(promptString.String())
	}

	// write prompt to current ansi request/response file
	err = os.WriteFile(progConfig.AnsiPromptResponseFile, []byte(ansiData), 0666)
	if err != nil {
		fmt.Printf("error [%v] at os.WriteFile()\n", err)
		return
	}

	// render prompt as html
	htmlData := promptString.String()
	if progConfig.HTMLRendering {
		htmlData = renderMarkdown2HTML(promptString.String())
	}

	// write prompt to current html request/response file
	err = os.WriteFile(progConfig.HTMLPromptResponseFile, []byte(htmlData), 0666)
	if err != nil {
		fmt.Printf("error [%v] at os.WriteFile()\n", err)
		return
	}
}

/*
processResponse processes the Gemini AI model's response and formats it for output. It takes the Gemini AI
response, extracts content from candidates, formats it into Markdown including citations and metadata, and
prepares for different output formats.
*/
func processResponse(resp *genai.GenerateContentResponse) {
	var responseString strings.Builder

	// print response candidate(s)
	for i, candidate := range resp.Candidates {
		if len(resp.Candidates) > 1 {
			responseString.WriteString(fmt.Sprintf("**Response from Gemini (Candidate #%d):**\n\n", (i + 1)))
		} else {
			responseString.WriteString("**Response from Gemini:**\n\n")
		}
		if candidate.Content == nil {
			responseString.WriteString("No content available in this candidate.\n")
			continue
		}
		for _, part := range candidate.Content.Parts {
			// print the part numbers (often not useful)
			// if len(candidate.Content.Parts) > 1 {
			// 	responseString.WriteString(fmt.Sprintf("\nPart #%d:\n", j+1))
			// }

			if part.VideoMetadata != nil {
				responseString.WriteString("Metadata for a given video.\n")
			}

			if part.Thought {
				responseString.WriteString("Indicates if the part is thought from the model.\n")
			}

			if part.CodeExecutionResult != nil {
				responseString.WriteString("Result of executing the [ExecutableCode].\n")
			}

			if part.ExecutableCode != nil {
				responseString.WriteString("Code generated by the model that is meant to be executed.\n")
			}

			if part.FileData != nil {
				responseString.WriteString(fmt.Sprintf("File Data: URI=%s, MIME=%s\n", part.FileData.FileURI, part.FileData.MIMEType))
			}

			if part.FunctionCall != nil {
				responseString.WriteString("A predicted [FunctionCall] returned from the model.\n")
			}

			if part.FunctionResponse != nil {
				responseString.WriteString("The result output of a [FunctionCall].\n")

			}
			if part.InlineData != nil {
				responseString.WriteString(fmt.Sprintf("Inline data (%.1f KiB, %s) : ", float64(len(part.InlineData.Data))/1024.0, part.InlineData.MIMEType))
				pathname, filename, err := writeDataToFile(part.InlineData.Data, part.InlineData.MIMEType, finishProcessing)
				if err != nil {
					responseString.WriteString(fmt.Sprintf("error [%v] writing data to file\n", err))
				} else {
					u := url.URL{
						Scheme: "file",
						Path:   pathname,
					}
					encodedURL := u.String()
					responseString.WriteString(fmt.Sprintf("[%s](%s)\n\n", filename, encodedURL))
				}
			}

			if part.Text != "" {
				// clean up markdown data given by Gemini
				responseString.WriteString(removeSpacesBetweenNewlineAndCodeblock(part.Text))
				responseString.WriteString("\n")
			}
		}
		responseString.WriteString("\n")

		// build list of text citation source URIs
		citationURIs := []string{}
		if candidate.CitationMetadata != nil {
			for _, citation := range candidate.CitationMetadata.Citations {
				if citation.URI != "" {
					citationURIs = append(citationURIs, (fmt.Sprintf("%v", citation.URI)))
				}
			}
		}

		// show text citation source URIs
		if len(citationURIs) > 0 {
			responseString.WriteString("\n***\n")
			responseString.WriteString(fmt.Sprintf("Text Citation %s:\n\n", pluralize(len(citationURIs), "Source")))
			for _, citationURI := range citationURIs {
				responseString.WriteString(fmt.Sprintf("* [%s](%s)\n", citationURI, citationURI))
			}
		}

		// build list of code citation licenses
		citationLicenses := []string{}
		if candidate.CitationMetadata != nil {
			for _, citation := range candidate.CitationMetadata.Citations {
				if citation.License != "" {
					citationLicenses = append(citationLicenses, citation.License)
				}
			}
		}

		// show code citation licenses (needs revision, output never seen)
		if len(citationLicenses) > 0 {
			responseString.WriteString("\n***\n")
			responseString.WriteString(fmt.Sprintf("Code Citation %s:\n\n", pluralize(len(citationLicenses), "License")))
			for _, citationSourceLicense := range citationLicenses {
				responseString.WriteString(fmt.Sprintf("* %s\n", citationSourceLicense))
			}
		}

		// show why the model stopped generating tokens (content) (needs revision, output never seen)
		if candidate.FinishReason != genai.FinishReasonStop {
			responseString.WriteString("\n***\n")
			responseString.WriteString(fmt.Sprintf("Model stopped generating tokens (content) with reason [%s].\n", candidate.FinishReason))
		}

		// show grounding metadata
		if candidate.GroundingMetadata != nil {
			// grounding: show list of used web resources (search sources)
			if candidate.GroundingMetadata.GroundingChunks != nil {
				responseString.WriteString("\n***\n")
				responseString.WriteString("**Online Search Sources Used:**\n\n")
				// numbered list because response can contain references (e.g. [2] or [1,3,15])
				for _, groundingChunk := range candidate.GroundingMetadata.GroundingChunks {
					responseString.WriteString(fmt.Sprintf("1. [%s](%s)\n", groundingChunk.Web.Title, groundingChunk.Web.URI))
				}
			}
			// grounding: show list of recommended web search queries (google search suggestions)
			if candidate.GroundingMetadata.WebSearchQueries != nil {
				responseString.WriteString("\n***\n")
				responseString.WriteString("**Google Search Suggestions:**\n\n")
				for _, webSearchQuery := range candidate.GroundingMetadata.WebSearchQueries {
					responseString.WriteString(fmt.Sprintf("* [%s](https://www.google.com/search?q=%s)\n", webSearchQuery, url.QueryEscape(webSearchQuery)))
				}
			}
		}

		responseString.WriteString("\n***\n")
	}

	// print response metadata
	responseString.WriteString("```plaintext\n")
	responseString.WriteString(fmt.Sprintf("AI model   : %v\n", resp.ModelVersion))
	responseString.WriteString(fmt.Sprintf("Generated  : %v\n", finishProcessing.Format(time.RFC850)))

	duration := finishProcessing.Sub(startProcessing)
	responseString.WriteString(fmt.Sprintf("Processing : %.1f secs for %d %s\n", duration.Seconds(),
		len(resp.Candidates), pluralize(len(resp.Candidates), "candidate")))

	if resp.UsageMetadata != nil {
		cachedContentTokenCount := "nil"
		if resp.UsageMetadata.CachedContentTokenCount != nil {
			cachedContentTokenCount = fmt.Sprintf("%v", *resp.UsageMetadata.CachedContentTokenCount)
		}
		candidatesTokenCount := "nil"
		if resp.UsageMetadata.CandidatesTokenCount != nil {
			candidatesTokenCount = fmt.Sprintf("%v", *resp.UsageMetadata.CandidatesTokenCount)
		}
		promptTokenCount := "nil"
		if resp.UsageMetadata.PromptTokenCount != nil {
			promptTokenCount = fmt.Sprintf("%v", *resp.UsageMetadata.PromptTokenCount)
		}
		responseString.WriteString(fmt.Sprintf("Tokens     : %v (CachedContent: %v, Prompt: %v, Candidates: %v)\n",
			resp.UsageMetadata.TotalTokenCount, cachedContentTokenCount, promptTokenCount, candidatesTokenCount))
	}
	/* needs revision, output never seen */
	if resp.PromptFeedback != nil {
		responseString.WriteString(fmt.Sprintf("Blocked    : %v\n", resp.PromptFeedback.BlockReasonMessage))
	}

	responseString.WriteString("```\n")
	responseString.WriteString("\n***\n")

	// append response string to request/response files
	appendResponseString(responseString)
}

/*
processError processes errors received from the Gemini AI model. It handles error responses from the Gemini AI
model, formats the error message in Markdown, and prepares it for output, including metadata about the error.
*/
func processError(err error) {
	var responseString strings.Builder

	// handle error response
	responseString.WriteString("**Error Response from Gemini:**\n\n")
	responseString.WriteString("```\n")
	responseString.WriteString(err.Error())
	responseString.WriteString("\n")

	responseString.WriteString("```\n")
	responseString.WriteString("\n***\n")

	// print response metadata
	responseString.WriteString("```plaintext\n")
	if err == nil {
		responseString.WriteString(fmt.Sprintf("AI model   : %v\n", progConfig.GeminiAiModel))
	}
	responseString.WriteString(fmt.Sprintf("Generated  : %v\n", finishProcessing.Format(time.RFC850)))

	duration := finishProcessing.Sub(startProcessing)
	responseString.WriteString(fmt.Sprintf("Processing : %.1f secs resulting in error\n", duration.Seconds()))

	responseString.WriteString("```\n")
	responseString.WriteString("\n***\n")

	// append response string to request/response files
	appendResponseString(responseString)
}

/*
appendResponseString appends a given response string (which can be a successful response or an error message)
to the current request / response files in Markdown, ANSI, and HTML formats.
*/
func appendResponseString(responseString strings.Builder) {
	// append response string to current markdown request/response file
	currentFileMarkdown, err := os.OpenFile(progConfig.MarkdownPromptResponseFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Printf("error [%v] at os.OpenFile()\n", err)
		return
	}
	defer currentFileMarkdown.Close()
	fmt.Fprint(currentFileMarkdown, responseString.String())

	// render markdown response as ansi
	ansiData := responseString.String()
	if progConfig.AnsiRendering {
		ansiData = renderMarkdown2Ansi(responseString.String())
	}

	// append response string to current ansi request/response file
	currentFileAnsi, err := os.OpenFile(progConfig.AnsiPromptResponseFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Printf("error [%v] at os.OpenFile()\n", err)
		return
	}
	defer currentFileAnsi.Close()
	fmt.Fprint(currentFileAnsi, ansiData)

	// render markdown response as html
	htmlData := responseString.String()
	if progConfig.HTMLRendering {
		htmlData = renderMarkdown2HTML(responseString.String())
	}

	// append response string to current html request/response file
	currentFileHTML, err := os.OpenFile(progConfig.HTMLPromptResponseFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		fmt.Printf("error [%v] at os.OpenFile()\n", err)
		return
	}
	defer currentFileHTML.Close()
	fmt.Fprint(currentFileHTML, htmlData)
}
